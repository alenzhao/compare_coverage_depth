# Determine the fraction of total coverage (depth x number_of_bases) per chromosome.
# Input is of the format generated by bedtools genomecov

### Input arguments ###
# 1) File name prefix.  The input sample file names are expected to be of the form "prefix""sampleID""suffix".
# 2) File name suffix.
# 3) Path to sample list.  Path to a file listing sample IDs to be processed.
# 4) Path to output summary table.
# 5) Comma delimited string of four numbers giving the 2D coordinates of two points on the line used to separate the data into two categories.
# 6) Path to output file listing the sample IDs and a label determining which group they were assigned to.
########################

# Load packages
print("using PyPlot\n")
using PyPlot

## Hard coded options

# sample ID tags
tag1="id#_"
tag2="_#bi"

# Scatter plot colours
colour1="cyan" # group1 colour
colour2="red" # group2 colour

#chromosomeY = "Y" # string corresponding to the naming convention used to indicate the Y chromosome (e.g. Y or chrY or ChrY or 24)

# Note: this list is expected to contain only strings
list_chromosomes = [ # Chromsomes of interest i.e. the main ones, excluding the obscure contigs
  "1"            
  "2"            
  "3"            
  "4"            
  "5"            
  "6"            
  "7"            
  "8"            
  "9"            
 "10"            
 "11"            
 "12"            
 "13"            
 "14"            
 "15"            
 "16"            
 "17"            
 "18"            
 "19"            
 "20"            
 "21"            
 "22"            
   "X"         
   "Y"         
   "MT"
   "genome"
]

#### Declare functions #####
function DiffAny(vec) # Crude implementation of a diff function for the Any data type
  len = length(vec)
  outvec = zeros(Integer, len)
  previous = nothing
  idx = 0
  for val in vec
    idx += 1
    # Check if different from previous value
    if val != previous
      outvec[idx] = 1
      previous = val
    end
  end
  return outvec
end

# expected input columns:  <chromsome::string> <coverage::int> <bases::int> <chromosome lenght::int> <fraction of chromsome at depth::float>
function GetCoverageDepth(arr::Any, rowStart::Int, rowFinish::Int, chr_name::Any)
  totalDepth = sum( arr[rowStart:rowFinish, 2] .* arr[rowStart:rowFinish, 3] )
  ## Additional check to make sure that the chromosome name in each row matches what is expected
  if length(unique(arr[rowStart:rowFinish, 1])) != 1 || string(unique(arr[rowStart:rowFinish, 1])[1]) != chr_name
    warn( "(in GetFractionChrDepth.jl GetCoverageDepth) expecting all rows to have \"",chr_name,"\" in column 1 but found: ",unique(arr[rowStart:rowFinish, 1]),'\n')
  end
  return totalDepth
end

# function GetFractionChrDepth(arr::Any, rowStart::Int, rowFinish::Int)
#   totalDepth = sum( arr[rowStart:rowFinish, 2] .* arr[rowStart:rowFinish, 5] )
#   return totalDepth
# end

function ProcessFile(filePath) # Extract fraction of coverage for each chromsome in list_chromsomes
  # Prepare arrays for holding results
  #arr_totalCov = zeros(Integer, length(list_chromosomes))
  arr_fracTotalCov = zeros(Float64, length(list_chromosomes))

  ## Read input file into array
  #print("Processing data from file: ", filePath, '\n')
  arr_file = readdlm(filePath)
  chromBegins = [ find(DiffAny(arr_file[:,1])); size(arr_file,1) ] # Rows at which data for each chromosome starts and the number of the final row of the file

  ## For each chromsome in the input file
  ## Get total depth at each chromsome of interest
  FLAG_found_genome = false # flag used to indicate the genome depth has been determined from an block of lines with the lable "genome" in the input file
  arr_chromDepth = zeros(Int, length(chromBegins)-1)
  GenomeDepth = 0.0
  for ichr in (1:length(chromBegins)-1)
    chr_name = string(arr_file[chromBegins[ichr]]) # get chromsome name
    # Extract coverage statistics for this chromsome
    chromCoverage = GetCoverageDepth(arr_file, chromBegins[ichr], chromBegins[ichr+1]-1, chr_name) # -1 because chromBegins[ichr+1] is the first row of the next chromosome
    #print(chromCoverage,'\t'); print(arr_file[chromBegins[ichr],1], '\n')
    arr_chromDepth[ichr] = chromCoverage

    ## Check if this is the whole genome section
    if chr_name == "genome"
      GenomeDepth = chromCoverage
      print("Normalisation to be done using depth of ", chr_name, ": ", GenomeDepth, '\n')
      FLAG_found_genome = true
    end

  end

  # May want to put in a catch in case "genome" rows are not found in the input file
  if FLAG_found_genome == false; print("ERROR (GetFractionDeothChr.jl): Failed to find rows for whole \"genome\" in the input file: ", filePath ) ; end

  ## Calculate fraction coverage at each chromosome
  icol = 1
  arr_chromFraction = zeros(Float64, length(chromBegins)-1)
  for ichr in (1:length(chromBegins)-1)
    #print(ichr,'\n')
    chromFraction = arr_chromDepth[ichr] / GenomeDepth
    arr_chromFraction[ichr] = chromFraction

    ## Output fraction of coverage for chromosomes of interest
    chr_name = string(arr_file[chromBegins[ichr]]) # Chromsome name
    # Check if this is one of the chromsomes of interest
    if chr_name in list_chromosomes
      arr_fracTotalCov[icol] = chromFraction
      icol += 1
    end
  end
  return arr_fracTotalCov
end

function GetIDBetweenTagsOrUseWhole(name, tag1, tag2)
  afterFirst = search(name, tag1)[end]+1 # find the position after tag1
  moreTag1  = search(name, tag1, afterFirst) # check for more occurances of tag1
  beforeSecond = search(name, tag2)[1]-1 # find the position before tag2
  moreTag2 =  search(name, tag2, beforeSecond+length(tag2)) # check for more occurances of tag2
  if moreTag1 != 0:-1 || moreTag2 != 0:-1 || afterFirst >= beforeSecond
    return name # cant figure out what the ID should be so use the whole string
  else
    return name[afterFirst:beforeSecond]  
  end
end

function FindChromsome(list, chromsome)
  idx = find(x -> x == chromsome, list)
  if length(idx) > 1; warn("(in GetFractionDepthChr.jl) found more than one chromsome matching \"",chromsome, "\" in the list", list); end
  return idx
end

searchdir(path,key) = filter(x->contains(x,key), readdir(path))
matchesprefix(path, prefix) = filter(x->(prefix == x[1:length(prefix)]), readdir(path)) 

function ExtractNonNaNs(array)
  idx_nonNaN = find(x->!isnan(x), array)
  arr_nonNaN = array[idx_nonNaN]
end

function ExtractNonNaNsBoth(arr1, arr2)
  idx1 = find(x->!isnan(x), arr1)
  idx2 = find(x->!isnan(x), arr2)
  idx12 = intersect(idx1, idx2)
  if length(idx12) != length(idx1)
    warn("(in GetFractionDepthChr.jl) possible column mismatch.")
  end
  arr_nonNaN = [arr1[idx12] arr2[idx12]]
end

function HistChromsomeCoverage(name)
  ## Extract coverage data for chromosome <name> for all non-NaN cases
  col = FindChromsome( list_chromosomes,  name )[1]
  print(name, " chromsome found in column ", col+1, " of the output file\n" )
  arr_nonNaN_C = ExtractNonNaNs(arr_sampleFractions[2:end, col+1])

  ## Plot distribution of chromsome coverage
  nbins = 100 # Number of bins
  fig = figure(name,figsize=(12,6)) # Not strictly required
  #ax = axes() # Not strictly required
  h = PyPlot.plt[:hist](arr_nonNaN_C,nbins) # create plot
end

function ScatterChromsomeCoverages(X, Y)
  # Extract data for selected chromsomes
  colX = FindChromsome( list_chromosomes, X )[1]
  colY = FindChromsome( list_chromosomes, Y )[1]
  arr_nonNaN_XY = ExtractNonNaNsBoth(arr_sampleFractions[2:end, colX+1], arr_sampleFractions[2:end, colY+1]);
  print("Scatter plot of coverages with ",X," on the horizontal axis and ",Y," on the vertical axis.")
  xvals = arr_nonNaN_XY[:,1];
  yvals = arr_nonNaN_XY[:,2];

  # Create plot
  scatter( xvals, yvals, c="b")
  xlabel(string("Fraction of total depth attributed to chromsome ",X))
  ylabel(string("Fraction of total depth attributed to chromsome ",Y))

  # Check to make sure there are no negative values (coverage should never be negative)
  if length(find( x-> x < 0.0, xvals)) > 0 || length(find( x-> x < 0.0, yvals)) > 0
    warn("(in GetFractionDepthChr.jl ScatterChromsomeCoverages) negative coverage values found.")
  else 
    gcf()
    xlim(xmin=0.0)
    ylim(ymin=0.0)
  end
end

# function OverlayLine(m, c) # Draw line on current figure
#   gcf()
#   xmin, xmax = xlim()
#   xdiff = xmax - xmin
#   xstep = xdiff/100.0
#   x = collect(xmin:xstep:xmax)
#   y = m.*x + c
#   plot(x,y)
# end

function OverlayLinePoints(pt1, pt2) # Draw line passing through two points on current figure
  m = (pt2[2] - pt1[2]) / (pt2[1] - pt1[1])
  c = pt1[2] - m * pt1[1]
  
  gcf()
  xmin, xmax = xlim()
  ymin, ymax = ylim()

  xdiff = xmax - xmin
  xstep = xdiff/100.0
  x_whole = collect(xmin:xstep:xmax)
  y_whole = m.*x_whole + c
  # Trim to prevent the plot from becoming bigger
  trim_low = find(x->x >= ymin, y_whole)
  trim_high = find(x->x <= ymax, y_whole)
  y = y_whole[intersect(trim_low, trim_high)]
  x = x_whole[intersect(trim_low, trim_high)]
  plot(x,y)
end

function IsNumeric(s::ASCIIString)
    isa(parse(s), Number)
end

function AskForFloat64(prompt::ASCIIString="")
  FLAG_number = false
  while FLAG_number == false
    print(prompt)
    string = chomp(readline())
    print(string, '\n')
    if IsNumeric(string)
      return Float64(parse(string))
    else
      print("This value needs to be convertable to the type of Float64.  Please try again.\n")
    end
  end
end

function PromptInput(prompt::ASCIIString="")
  print(prompt)
  chomp(readline())
end

# function LineToPoint(lineSeparating)
#   dtx = AskForFloat64("test x-coordinate: ")
#   dty = AskForFloat64("test y-coordinate: ")
#   lineSeparating = [pt2x; pt2y; 0.0] - [pt1x; pt1y; 0.0]
#   lineToData = [dtx; dty; 0.0] - [pt1x; pt1y; 0.0]
#   fromSeparating = ( cross(lineToData, lineSeparating) / norm(lineSeparating) )[3]
# end

function LineToPointNaNs(dtx, dty, pt1x, pt1y, pt2x, pt2y)
  if dtx == NaN || dty == NaN
    return NaN
  end
  lineSeparating = [pt2x; pt2y; 0.0] - [pt1x; pt1y; 0.0]
  lineToData = [dtx; dty; 0.0] - [pt1x; pt1y; 0.0]
  fromSeparating = ( cross(lineToData, lineSeparating) / norm(lineSeparating) )[3]
end

function SegregateByCoverage(X, Y) # pt1x, pt1y, pt2x, pt2y  set in the environment
  colX = FindChromsome( list_chromosomes, X )[1]
  colY = FindChromsome( list_chromosomes, Y )[1]
  #arr_nonNaN_XY = ExtractNonNaNsBoth(arr_sampleFractions[2:end, colX+1], arr_sampleFractions[2:end, colY+1])
  #print("Scatter plot of coverages with ",X," on the horizontal axis and ",Y," on the vertical axis.")
  
  ## Determine the distance from the data point to the segregating line in 2D
  rows = size(arr_sampleFractions,1)
  dist = fill(NaN, rows)
  for idx in (2:rows) # row 1 is the headder
    #print(idx,'\n')
    dtx = arr_sampleFractions[idx, colX+1]
    dty = arr_sampleFractions[idx, colY+1]
    dist[idx] = LineToPointNaNs(dtx, dty, pt1x, pt1y, pt2x, pt2y)
  end

  ## Assign the data to group1 or group2 based on the sign of the distance (cross product / line lenght)
  igr1 = find(x -> sign(x) == -1, dist)
  igr2 = find(x -> sign(x) == 1, dist)
                # sample ID                # chromosome (x)                 # chromosome(y)
  group1 = [ arr_sampleFractions[igr1, 1] arr_sampleFractions[igr1, colX+1] arr_sampleFractions[igr1, colY+1] ]
  group2 = [ arr_sampleFractions[igr2, 1] arr_sampleFractions[igr2, colX+1] arr_sampleFractions[igr2, colY+1] ]

  ## Plot each group in a different colour
  scatter( group1[:,2], group1[:,3], c="cyan")
  scatter( group2[:,2], group2[:,3], c="red")

  return dist, group1, group2
end

#############################

#### SCRIPT #####

# file_prefix = "genomecov/genomecov_id#_"
# file_suffix = "_#bi.txt"
# file_samples = "seqIDs_N_MMM_500exomes_sorted.txt"
# file_output = "table_chromosome_coverage.txt"
# separating_vector_string = "0.03,0,0.035,0.004"
# group1label = "M"
# group2label = "F"
# file_groups = "groups"


## Process command line arguments
print("Aguments: ", ARGS[1:end])
file_prefix = ARGS[1]  # "pre/fix""sampleID""suffix"
file_suffix = ARGS[2]  # "pre/fix""sampleID""suffix"
file_samples = ARGS[3] # file listing samples to be processed
file_output = ARGS[4]  # output table file
separating_vector_string = ARGS[5] # comma delimited string of four numbers giving the 2D coordinates of two points on the line used to separate the data into two categories
file_groups = ARGS[6] # file listing sample names and associated group labels


print("Running GetFractionDepthChr.jl on files of the form ",file_prefix,"<sampleID>",file_suffix,'\n')
arr_samples = readdlm(file_samples, '\t')[:,1]; # assuming tab delimited

## Create array for holding the fractions of coverage by chromsome for each sample (rows are samples, columns are chromsomes)
num_samples = length(arr_samples)
arr_sampleFractions = Array(Any, num_samples+1, length(list_chromosomes)+1)
arr_sampleFractions[1,1] = "Sample"
arr_sampleFractions[1,2:end] = list_chromosomes

## Process files and save results to array
ifile = 0
for sample in arr_samples;
  ifile += 1
  filePath = string( file_prefix, sample, file_suffix)
  print("Processing file (", ifile, " of ", num_samples,"): ", filePath, '\n')
  sampleName = sample #GetIDBetweenTagsOrUseWhole(sample, tag1, tag2)
  arr_sampleFractions[ifile+1, 1] = sampleName
  if stat(filePath).size != 0 # Check that file is not zero sized
    arr_sampleFractions[ifile+1, 2:end] = ProcessFile(filePath)
  else
    arr_sampleFractions[ifile+1, 2:end] = NaN
  end
end
writedlm(file_output, arr_sampleFractions, '\t')

# Plot histogram
#HistChromsomeCoverage(chromosomeY)
#savefig(string("coverage_", chromosomeY, ".png"))



## Ask the user to draw a line separating the data into two categories
chromHoriz="X"
chromVert="Y"
ScatterChromsomeCoverages(chromHoriz, chromVert)
figname = string("coverages_", chromHoriz, "_", chromVert, ".png")
print("Saving figure to: ",figname,"\n"); savefig(figname);
userYN = ""
tries = 0
str1x, str1y, str2x, str2y = "", "", "", ""
pt1x, pt1y, pt2x, pt2y = NaN, NaN, NaN, NaN
while (userYN != "y" && userYN != "yes" && userYN != "Y" && userYN != "Yes")
  tries += 1
  #print("userYN = ", userYN, '\n')
  if tries == 1
    try 
      str1x, str1y, str2x, str2y = split(separating_vector_string, ',')
      pt1x = Float64(parse(str1x))
      pt1y = Float64(parse(str1y))
      pt2x = Float64(parse(str2x))
      pt2y = Float64(parse(str2y))
    catch
      print("Input two points defining a line in 2-D to separate the samples into two groups.\nThe order of the points determiens the order of the groups.\n")
      pt1x = AskForFloat64("Separating line first point x-coordinate: ")
      pt1y = AskForFloat64("Separating line first point y-coordinate: ")
      pt2x = AskForFloat64("Separating line second point x-coordinate: ")
      pt2y = AskForFloat64("Separating line second point y-coordinate: ")
    end
  else
    print("Input two points defining a line in 2-D to separate the samples into two groups.\nThe order of the points determiens the order of the groups.\n")
    pt1x = AskForFloat64("Separating line first point x-coordinate: ")
    pt1y = AskForFloat64("Separating line first point y-coordinate: ")
    pt2x = AskForFloat64("Separating line second point x-coordinate: ")
    pt2y = AskForFloat64("Separating line second point y-coordinate: ")
  end
  ## Draw line on scatter plot
  OverlayLinePoints([pt1x pt1y], [pt2x pt2y])
  figname = string("coverages_", chromHoriz, "_", chromVert, ".png")
  print("Saving figure to: ",figname,"\n"); savefig(figname);
  ## Ask user if it is any good
  userYN = PromptInput("Use current line? (yes/no/clear/stop): ")
  if userYN == "clear"
    clf()
    ScatterChromsomeCoverages(chromHoriz, chromVert)
    figname = string("coverages_", chromHoriz, "_", chromVert, ".png")
    print("Saving figure to: ",figname,"\n"); savefig(figname);
  end
  if userYN == "stop"; break; end
end

distances, group1, group2 = SegregateByCoverage(chromHoriz, chromVert)  # pt1x, pt1y, pt2x, pt2y  set in the environment
figname = string("coverages_", chromHoriz, "_", chromVert, ".png")
print("Saving figure to: ",figname,"\n"); savefig(figname);

## Ask the user to indicate what label to give to group1 and group2
label1 = PromptInput(string("Input label for group 1 (",colour1,"): " ))
label2 = PromptInput(string("Input label for group 2 (",colour2,"): " ))

## Write groups to output file with the corresponding labels
print("Writing groups to file: ", file_groups, "\n")
arr_groups = [ group1[:,1] fill(label1, size(group1,1)) ; group2[:,1] fill(label2, size(group2,1)) ]
writedlm(file_groups, arr_groups, '\t')

## Write 
# save line coordinates to shell variable
print("\n")

#################

## Misc

# for cn in list_chromosomes[1:2:end]
#   print(cn,'\n')
#   #HistChromsomeCoverage(cn)
#   figure()
#   ScatterChromsomeCoverages(cn, "Y")
# end

# EOF




